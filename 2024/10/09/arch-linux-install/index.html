<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>marsevilspirit&#39;s blog</title><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,viewport-fit=cover"><link rel="canonical" href="https://www.marsevilspirit.com/"><link rel="apple-touch-icon" sizes="180x180" href="/img/marsevilspirit.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/marsevilspirit.png"><link rel="icon" type="image/png" sizes="16x16" href="/img/marsevilspirit.png"><link rel="mask-icon" type="image/png" href="/img/marsevilspirit.png"><link rel="stylesheet" href="/css/normalize.css"><link rel="stylesheet" href="/css/et-book.min.css"><link rel="stylesheet" href="/css/LXGW.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/markdown.css"><link rel="stylesheet" href="/css/highlight/style1.css"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="marsevilspirit's blog" type="application/atom+xml">
</head><body><div class="wrapper"><div class="container"><header><h2><a href="/">marsevilspirit&#39;s blog</a></h2></header></div><div class="content"><div class="post"><h1>archlinux 的安装</h1><main class="post-md"><p>开始之前先听首歌放松一下。</p><iframe allow="autoplay *; encrypted-media *; fullscreen *; clipboard-write" frameborder="0" height="175" style="width:100%;max-width:660px;overflow:hidden;border-radius:10px" sandbox="allow-forms allow-popups allow-same-origin allow-scripts allow-storage-access-by-user-activation allow-top-navigation-by-user-activation" src="https://embed.music.apple.com/cn/album/%E6%B5%B7%E3%81%AB%E8%A1%8C%E3%81%8F/1591596363?i=1591596364"></iframe><p>安装arch之前，我们需要明确一件事情，archlinux的安装不是一件折磨的事情，我们应该在安装的过程中，感受arch linux的美妙，体会CLI的乐趣，这样在能在arch的道路上走的越长远，成为一个合格的arch linux用户。</p><p>该安装教程会实时更新，本人会每个月至少一次在虚拟机中安装archlinux，使用最新的iso，以确保该安装教程的时效性。</p><p>关于 archinstall 的提示(arch wiki原话):</p><blockquote><p>不建议初学者用 archinstall 走捷径，因为手动安装 archlinux 本身就是 archlinux 教学实操的一环，少了这个环节，会让初学者面对一些基础问题时束手无策，为自己和社区带来不必要的麻烦。</p></blockquote><p>等熟练了，就可以用archinstall逃课了。</p><h3 id="1-下载安装镜像"><a href="#1-下载安装镜像" class="headerlink" title="1.下载安装镜像"></a>1.下载安装镜像</h3><p>推荐在<a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学开源软件镜像站</a>下载，体验很好。<br>一定要下载最新的安装镜像。</p><h3 id="2-刻录安装-U-盘"><a href="#2-刻录安装-U-盘" class="headerlink" title="2.刻录安装 U 盘"></a>2.刻录安装 U 盘</h3><p>准备一个 2G 以上的 U 盘，刻录一个安装盘。<br>这里我只推荐 Ventoy 进行 U 盘刻录，因为它实在是太强大了!!!<br>Ventoy 的使用这里不再赘述，网上教程很多。</p><h3 id="3-为-archlinux-分出硬盘空间"><a href="#3-为-archlinux-分出硬盘空间" class="headerlink" title="3.为 archlinux 分出硬盘空间"></a>3.为 archlinux 分出硬盘空间</h3><p>我认为至少需要分128GB以上，个人看法。<br>分盘就用windows自带的磁盘管理就行，具体操作网上有教程。<br>DiskGenius也是一个很好的分盘工具，比较推荐用这个。</p><h3 id="4-进入主板-BIOS-进行设置"><a href="#4-进入主板-BIOS-进行设置" class="headerlink" title="4. 进入主板 BIOS 进行设置"></a>4. 进入主板 BIOS 进行设置</h3><p>不同电脑进入方法不同，google一下。</p><p>进入之后：</p><ul><li>关闭 BIOS 设置中的 Secure Boot</li><li>调整启动方式为 UEFI</li><li>调整硬盘启动顺序，设置 U 盘为最上面</li></ul><p>之后保存退出。</p><h3 id="5-有线网络还是无线网络"><a href="#5-有线网络还是无线网络" class="headerlink" title="5.有线网络还是无线网络"></a>5.有线网络还是无线网络</h3><p>如果是无线网络，事先把要连接的wifi名字改成英文，tty环境下无法显示中文，导致无法连上网络。</p><h3 id="6-准备安装"><a href="#6-准备安装" class="headerlink" title="6.准备安装"></a>6.准备安装</h3><p>不出意外的话，重启之后就会进入 U 盘的安装引导中。<br>选择第一个选项即可。<br>应该可以顺利进入 archlinux 的安装界面了。</p><h3 id="7-验证是否以UEFI的方式启动"><a href="#7-验证是否以UEFI的方式启动" class="headerlink" title="7.验证是否以UEFI的方式启动"></a>7.验证是否以UEFI的方式启动</h3><p>要验证系统目前的引导模式，请检查 UEFI 位数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># cat /sys/firmware/efi/fw_platform_size</span><br></pre></td></tr></table></figure><p>如果命令结果为 64，则系统是以 UEFI 模式引导且使用 64 位 x64 UEFI。<br>如果命令结果为 32，则系统是以 UEFI 模式引导且使用 32 位 IA32 UEFI，虽然其受支持，但引导加载程序只能使用 systemd-boot和GRUB。<br>如果文件不存在，说明不是以UEFI的方式启动，则不能在该教程继续安装。</p><p>验证成功后进行下一步。</p><h3 id="8-连接网络"><a href="#8-连接网络" class="headerlink" title="8.连接网络"></a>8.连接网络</h3><h4 id="8-1-确保系统已经列出并启用了网络接口"><a href="#8-1-确保系统已经列出并启用了网络接口" class="headerlink" title="8.1 确保系统已经列出并启用了网络接口"></a>8.1 确保系统已经列出并启用了网络接口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ip link</span><br></pre></td></tr></table></figure><p>如何没有列出网卡，需要启用网卡。</p><h4 id="8-2-有线网络或无线网络"><a href="#8-2-有线网络或无线网络" class="headerlink" title="8.2 有线网络或无线网络"></a>8.2 有线网络或无线网络</h4><ul><li>有线网络不用管，会自动连接</li><li>无线网络需要通过iwctl连接网络，网上有教程。</li></ul><h4 id="8-3-验证网络是否连接"><a href="#8-3-验证网络是否连接" class="headerlink" title="8.3 验证网络是否连接"></a>8.3 验证网络是否连接</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ping www.bilibili.com</span><br></pre></td></tr></table></figure><p>有数据包来往说明网络连接成功。</p><h3 id="9-更新系统时钟"><a href="#9-更新系统时钟" class="headerlink" title="9.更新系统时钟"></a>9.更新系统时钟</h3><p>使用 timedatectl 更新系统时钟。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># timedatectl set-ntp true # 将系统时间与网络时间进行同步</span><br><span class="line"># timedatectl status # 检查服务状态</span><br></pre></td></tr></table></figure><p>输出中显示NTP service: active就可以了。</p><h3 id="10-换源加快下载速度"><a href="#10-换源加快下载速度" class="headerlink" title="10.换源加快下载速度"></a>10.换源加快下载速度</h3><h4 id="10-1-禁用-reflector-服务"><a href="#10-1-禁用-reflector-服务" class="headerlink" title="10.1 禁用 reflector 服务"></a>10.1 禁用 reflector 服务</h4><p>reflector是archlinux安装镜像自带的换源工具，在特定情况下，它会误删某些有用的源信息，所以我们禁用它。</p><p>通过以下命令将该服务禁用:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># systemctl stop reflector.service</span><br></pre></td></tr></table></figure><p>通过以下命令查看该服务是否被禁用，按下 q 退出结果输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># systemctl status reflector.service</span><br></pre></td></tr></table></figure><p>Active: inactive (dead)就对了。</p><h4 id="10-2-更换国内软件仓库镜像源"><a href="#10-2-更换国内软件仓库镜像源" class="headerlink" title="10.2 更换国内软件仓库镜像源"></a>10.2 更换国内软件仓库镜像源</h4><p>使用 vim 编辑器修改 &#x2F;etc&#x2F;pacman.d&#x2F;mirrorlist 文件。将 pacman 软件仓库源更换为国内软件仓库镜像源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure><p>放在最上面的是会使用的软件仓库镜像源，推荐的镜像源如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Server = https://mirrors.bfsu.edu.cn/archlinux/$repo/os/$arch</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch </span><br><span class="line">Server = https://repo.huaweicloud.com/archlinux/$repo/os/$arch </span><br><span class="line">Server = http://mirror.lzu.edu.cn/archlinux/$repo/os/$arch </span><br><span class="line">Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch </span><br></pre></td></tr></table></figure><p>将以上内容放入文件中即可。</p><h3 id="11-分区和格式化（使用-Btrfs-文件系统）"><a href="#11-分区和格式化（使用-Btrfs-文件系统）" class="headerlink" title="11.分区和格式化（使用 Btrfs 文件系统）"></a>11.分区和格式化（使用 Btrfs 文件系统）</h3><p><strong>警告</strong>: 接下来的每一个命令要慎重输入，确保每一条命令是正确的，否则最坏的情况会把windows格式化。</p><h4 id="11-1-查看当前磁盘的分区情况"><a href="#11-1-查看当前磁盘的分区情况" class="headerlink" title="11.1 查看当前磁盘的分区情况"></a>11.1 查看当前磁盘的分区情况</h4><p>通过 lsblk 命令，区分要安装 archlinux 的磁盘（通过观察磁盘的大小、已存在的分区情况等判断）并显示当前磁盘的分区情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># lsblk # 显示当前分区情况</span><br></pre></td></tr></table></figure><p>以下是我的输出(已经成功安装archlinux):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mars ~/ $ lsblk                        </span><br><span class="line">NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS</span><br><span class="line">zram0       254:0    0     4G  0 disk [SWAP]</span><br><span class="line">nvme0n1     259:0    0 953.9G  0 disk </span><br><span class="line">├─nvme0n1p1 259:1    0   512M  0 part /boot</span><br><span class="line">├─nvme0n1p2 259:2    0    16M  0 part </span><br><span class="line">├─nvme0n1p3 259:3    0   400G  0 part </span><br><span class="line">├─nvme0n1p4 259:4    0   400G  0 part </span><br><span class="line">└─nvme0n1p5 259:5    0 153.4G  0 part /</span><br></pre></td></tr></table></figure><p>我们主要需要三个分区：</p><ol><li>EFI分区</li><li>&#x2F; 分区</li><li>swap分区</li></ol><h4 id="11-2-对磁盘分区"><a href="#11-2-对磁盘分区" class="headerlink" title="11.2 对磁盘分区"></a>11.2 对磁盘分区</h4><p>接下来使用 cfdisk 命令对磁盘分区(对于 NVME 协议的硬盘，x 为数字 0、1 或 2 等等，请根据实际情况判断）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># cfdisk /dev/nvmexn1 # 对安装 archlinux 的磁盘分区</span><br></pre></td></tr></table></figure><p>进入 cfdisk 分区工具之后，通过方向键 ↑ 和 ↓ 可以在要操作磁盘分区或空余空间中移动；通过方向键 ← 和 → 在对当前高亮的磁盘分区或空余空间要执行的操作中移动。</p><h5 id="11-2-1-创建-Swap-分区"><a href="#11-2-1-创建-Swap-分区" class="headerlink" title="11.2.1 创建 Swap 分区"></a>11.2.1 创建 Swap 分区</h5><p>选中之前在windows分好的 Free space &gt; 再选中操作 [New] &gt; 然后按下回车 Enter 以新建 swap 分区。<br>按下回车后会提示输入 分区大小(别忘了单位: GB 或 MB)，Swap 分区建议为电脑内存大小的 60%，或者和内存大小相等 &gt; 然后按下回车 Enter。<br>默认新建的类型是 Linux filesystem，我们需要将类型更改为 Linux swap。选中操作 [Type] &gt; 然后按下回车 Enter &gt; 通过方向键 ↑ 和 ↓ 选中 Linux swap &gt; 最后按下回车 Enter。</p><h5 id="11-2-2-创建-Btrfs-文件系统的分区"><a href="#11-2-2-创建-Btrfs-文件系统的分区" class="headerlink" title="11.2.2 创建 Btrfs 文件系统的分区"></a>11.2.2 创建 Btrfs 文件系统的分区</h5><p>我们再只需要一个分区即可（因为使用 Btrfs 文件系统，所以根目录和用户主目录在一个分区上），所以类似的：选中 Free space &gt; 再选中操作 [New] &gt; 然后按下回车 Enter 以新建分区。<br>输入 分区大小（默认是剩余的全部空间。请根据实际情况输入）&gt; 然后按下回车 Enter。</p><h5 id="11-2-3-将创建好的分区写入"><a href="#11-2-3-将创建好的分区写入" class="headerlink" title="11.2.3 将创建好的分区写入"></a>11.2.3 将创建好的分区写入</h5><p>分区类型默认即可，无需更改。接下来选中操作 [Write] 并回车 Enter &gt; 输入 yes 并回车 Enter 确认分区操作。<br>选中操作 [Quit] 并回车 Enter 以退出 cfdisk 分区工具。</p><h4 id="11-3-复查分区情况"><a href="#11-3-复查分区情况" class="headerlink" title="11.3 复查分区情况"></a>11.3 复查分区情况</h4><p>分区完成后，使用 fdisk 或 lsblk 命令复查分区情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># fdisk -l # 复查磁盘情况</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># lsblk # 复查磁盘情况</span><br></pre></td></tr></table></figure><p>输出信息符合预期即可。</p><h4 id="11-4-格式化并创建-Btrfs-子卷"><a href="#11-4-格式化并创建-Btrfs-子卷" class="headerlink" title="11.4 格式化并创建 Btrfs 子卷"></a>11.4 格式化并创建 Btrfs 子卷</h4><h5 id="11-4-1-格式化-EFI-分区"><a href="#11-4-1-格式化-EFI-分区" class="headerlink" title="11.4.1 格式化 EFI 分区"></a>11.4.1 格式化 EFI 分区</h5><p><strong>警告</strong>：如果目标是双系统（Win10&#x2F;Win11 + Arch Linux），并且 Win10&#x2F;Win11 和 Arch Linux 将要共存在一个硬盘上的话，不要重新格式化原有的 EFI 分区，因为它可能包含启动其他操作系统所需的文件。</p><p><strong>警告</strong>：如果是双系统不要运行下面命令，跳过进行下一步。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mkfs.fat -F32 /dev/nvmexn1pn # 按分区情况替换nvmexn1pn</span><br></pre></td></tr></table></figure><h5 id="11-4-2-格式化-Swap-分区"><a href="#11-4-2-格式化-Swap-分区" class="headerlink" title="11.4.2 格式化 Swap 分区"></a>11.4.2 格式化 Swap 分区</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mkswap /dev/nvmexn1pn # 按分区情况替换nvmexn1pn</span><br></pre></td></tr></table></figure><h5 id="11-4-3-格式化-Btrfs-分区"><a href="#11-4-3-格式化-Btrfs-分区" class="headerlink" title="11.4.3 格式化 Btrfs 分区"></a>11.4.3 格式化 Btrfs 分区</h5><h6 id="11-4-3-1-格式化"><a href="#11-4-3-1-格式化" class="headerlink" title="11.4.3.1 格式化"></a>11.4.3.1 格式化</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mkfs.btrfs -L myArch /dev/nvmexn1pn # 按分区情况替换nvmexn1pn</span><br></pre></td></tr></table></figure><h6 id="11-4-3-2-挂载到-mnt"><a href="#11-4-3-2-挂载到-mnt" class="headerlink" title="11.4.3.2 挂载到 &#x2F;mnt"></a>11.4.3.2 挂载到 &#x2F;mnt</h6><p>为了创建子卷，我们需要先将 Btrfs 分区挂载到 &#x2F;mnt 下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mount -t btrfs -o compress=zstd /dev/nvmexn1pn /mnt # 按分区情况替换nvmexn1pn</span><br></pre></td></tr></table></figure><h6 id="11-4-3-3-复查挂载情况"><a href="#11-4-3-3-复查挂载情况" class="headerlink" title="11.4.3.3 复查挂载情况"></a>11.4.3.3 复查挂载情况</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># df -h # -h 选项会使输出以人类可读的单位显示</span><br></pre></td></tr></table></figure><h5 id="11-4-4-创建-Btrfs-子卷"><a href="#11-4-4-创建-Btrfs-子卷" class="headerlink" title="11.4.4 创建 Btrfs 子卷"></a>11.4.4 创建 Btrfs 子卷</h5><p>通过以下命令创建两个 Btrfs 子卷，之后将分别挂载到 &#x2F; 根目录和 &#x2F;home 用户主目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># btrfs subvolume create /mnt/@ # 创建 / 目录子卷</span><br><span class="line"># btrfs subvolume create /mnt/@home # 创建 /home 目录子卷</span><br></pre></td></tr></table></figure><p>通过以下命令复查子卷情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btrfs subvolume list -p /mnt</span><br></pre></td></tr></table></figure><p>子卷创建好后，我们需要将 &#x2F;mnt 卸载掉，以挂载子卷：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount /mnt</span><br></pre></td></tr></table></figure><h4 id="11-5-挂载"><a href="#11-5-挂载" class="headerlink" title="11.5 挂载"></a>11.5 挂载</h4><p><strong>警告</strong>：注意应该挂载的nvmexn1pn, 下面的命令每个该挂载的nvmexn1pn各不相同。</p><p>在挂载时，挂载是有顺序的，需要从根目录开始挂载。使用如下命令挂载子卷：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># mount -t btrfs -o subvol=/@,compress=zstd /dev/nvmexn1pn /mnt # 挂载 / 目录</span><br><span class="line"># mkdir /mnt/home # 创建 /home 目录</span><br><span class="line"># mount -t btrfs -o subvol=/@home,compress=zstd /dev/nvmexn1pn /mnt/home # 挂载 /home 目录</span><br><span class="line"># mkdir -p /mnt/boot # 创建 /boot 目录</span><br><span class="line"># mount /dev/nvmexn1pn /mnt/boot # 挂载 /boot 目录</span><br><span class="line"># swapon /dev/nvmexn1pn # 挂载交换分区</span><br></pre></td></tr></table></figure><p>使用 df 命令复查挂载情况:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># df -h</span><br></pre></td></tr></table></figure><p>使用 free 命令复查 Swap 分区挂载情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># free -h</span><br></pre></td></tr></table></figure><p>输出符合预期即可。</p><h3 id="12-安装系统"><a href="#12-安装系统" class="headerlink" title="12.安装系统"></a>12.安装系统</h3><p>到这里就可以轻松一些了, 这里会下载一段时间。</p><p>通过如下命令使用 pacstrap 脚本安装基础包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pacstrap /mnt base base-devel linux linux-firmware btrfs-progs</span><br><span class="line"># 如果使用btrfs文件系统，额外安装一个btrfs-progs包</span><br></pre></td></tr></table></figure><p>通过如下命令使用 pacstrap 脚本安装其它必要的功能性软件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacstrap /mnt networkmanager vim sudo zsh zsh-completions</span><br></pre></td></tr></table></figure><h3 id="13-生成-fstab-文件"><a href="#13-生成-fstab-文件" class="headerlink" title="13.生成 fstab 文件"></a>13.生成 fstab 文件</h3><p>fstab 用来定义磁盘分区。它是 Linux 系统中重要的文件之一。使用 genfstab 自动根据当前挂载情况生成并写入 fstab 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># genfstab -U /mnt &gt; /mnt/etc/fstab</span><br></pre></td></tr></table></figure><p>复查一下 &#x2F;mnt&#x2F;etc&#x2F;fstab 确保没有错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /mnt/etc/fstab</span><br></pre></td></tr></table></figure><p>输出结果应该与此类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># /dev/nvme0n1p6  /  btrfs  rw,relatime,compress=zstd:3,ssd,space_cache,subvolid=256,subvol=/@,subvol=@ 0 0</span><br><span class="line">UUID=d01a3ca5-0798-462e-9a30-97065e7e36e1 /  btrfs  rw,relatime,compress=zstd:3,ssd,space_cache,subvolid=256,subvol=/@,subvol=@  0 0</span><br><span class="line"></span><br><span class="line"># /dev/nvme0n1p1  /boot vfat  rw,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=ascii,shortname=mixed,utf8,errors=remount-ro      0 2</span><br><span class="line">UUID=522C-80C6  /boot vfat  rw,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=ascii,shortname=mixed,utf8,errors=remount-ro 0 2</span><br><span class="line"></span><br><span class="line"># /dev/nvme0n1p6  /home btrfs rw,relatime,compress=zstd:3,ssd,space_cache,subvolid=257,subvol=/@home,subvol=@home 0 0</span><br><span class="line">UUID=d01a3ca5-0798-462e-9a30-97065e7e36e1 /home btrfs rw,relatime,compress=zstd:3,ssd,space_cache,subvolid=257,subvol=/@home,subvol=@home 0 0</span><br><span class="line"></span><br><span class="line"># /dev/nvme0n1p5  none  swap  defaults  0 0</span><br><span class="line">UUID=8e40dbed-590f-4cb8-80de-5cef8343a9fc none  swap  defaults  0 0</span><br></pre></td></tr></table></figure><h3 id="14-change-root"><a href="#14-change-root" class="headerlink" title="14.change root"></a>14.change root</h3><p>使用以下命令把系统环境切换到新系统下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># arch-chroot /mnt</span><br></pre></td></tr></table></figure><p>此时，原来安装盘下的 &#x2F;mnt 目录就变成了新系统的 &#x2F; 目录。同时，可以发现命令行的提示符颜色和样式也发生了改变。</p><h3 id="15-设置主机名与时区"><a href="#15-设置主机名与时区" class="headerlink" title="15.设置主机名与时区"></a>15.设置主机名与时区</h3><p>首先在 &#x2F;etc&#x2F;hostname 设置主机名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/hostname</span><br></pre></td></tr></table></figure><p>加入你想为主机取的主机名。</p><p>接下来在 &#x2F;etc&#x2F;hosts 设置与其匹配的条目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/hosts</span><br></pre></td></tr></table></figure><p>加入如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1   localhost</span><br><span class="line">::1         localhost</span><br><span class="line">127.0.1.1   ROG.localdomain ROG</span><br></pre></td></tr></table></figure><p>随后设置时区，在 &#x2F;etc&#x2F;localtime 下用 &#x2F;usr 中合适的时区创建符号链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure><h3 id="16-硬件时间设置"><a href="#16-硬件时间设置" class="headerlink" title="16.硬件时间设置"></a>16.硬件时间设置</h3><p>使用如下命令将系统时间同步到硬件时间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># hwclock --systohc</span><br></pre></td></tr></table></figure><h3 id="17-设置-Local"><a href="#17-设置-Local" class="headerlink" title="17.设置 Local"></a>17.设置 Local</h3><p>Locale 决定了软件使用的语言、书写习惯和字符集。</p><p>编辑 &#x2F;etc&#x2F;locale.gen，去掉 en_US.UTF-8 UTF-8 以及 zh_CN.UTF-8 UTF-8 行前的注释符号（#）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/locale.gen</span><br></pre></td></tr></table></figure><p>然后使用如下命令生成 locale：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># locale-gen</span><br></pre></td></tr></table></figure><p>向 &#x2F;etc&#x2F;locale.conf 输入内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># echo &#x27;LANG=en_US.UTF-8&#x27;  &gt; /etc/locale.conf</span><br></pre></td></tr></table></figure><h3 id="18-为-root-用户设置密码"><a href="#18-为-root-用户设置密码" class="headerlink" title="18.为 root 用户设置密码"></a>18.为 root 用户设置密码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># passwd root</span><br></pre></td></tr></table></figure><h3 id="19-安装微码"><a href="#19-安装微码" class="headerlink" title="19.安装微码"></a>19.安装微码</h3><p>通过以下命令安装对应芯片制造商的微码(安装对应的微码)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># pacman -S intel-ucode # Intel</span><br><span class="line"># pacman -S amd-ucode # AMD</span><br></pre></td></tr></table></figure><h3 id="20-安装引导程序"><a href="#20-安装引导程序" class="headerlink" title="20.安装引导程序"></a>20.安装引导程序</h3><p>安装相应的包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pacman -S grub efibootmgr os-prober</span><br></pre></td></tr></table></figure><p>安装 GRUB 到 EFI 分区：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=ARCH</span><br></pre></td></tr></table></figure><p>接下来使用 vim 编辑 &#x2F;etc&#x2F;default&#x2F;grub 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/default/grub</span><br></pre></td></tr></table></figure><p>进行如下修改：</p><p>去掉 GRUB_CMDLINE_LINUX_DEFAULT 一行中最后的 quiet 参数<br>把 loglevel 的数值从 3 改成 5。这样是为了后续如果出现系统错误，方便排错<br>加入 nowatchdog 参数，这可以显著提高开关机速度</p><p>为了引导 win10，则还需要添加新的一行 GRUB_DISABLE_OS_PROBER&#x3D;false</p><p>最后生成 GRUB 所需的配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><h3 id="21-完成安装"><a href="#21-完成安装" class="headerlink" title="21.完成安装"></a>21.完成安装</h3><p>输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># exit # 退回安装环境</span><br><span class="line"># umount -R /mnt # 卸载新分区</span><br><span class="line"># reboot # 重启</span><br></pre></td></tr></table></figure><p>注意，重启前要先拔掉优盘，否则你重启后还是进安装程序而不是安装好的系统。</p><p>重启后使用 root 账户登录系统。</p><p>设置开机自启并立即启动 networkmanager 服务，即可连接网络：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># systemctl enable --now NetworkManager # 设置开机自启并立即启动 NetworkManager 服务</span><br><span class="line"># ping www.bilibili.com # 测试网络连接 </span><br></pre></td></tr></table></figure><p>若为无线连接，则需要在启动 networkmanager 后使用 nmcli 连接网络：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># nmcli dev wifi list # 显示附近的 Wi-Fi 网络</span><br><span class="line"># nmcli dev wifi connect &quot;Wi-Fi名（SSID）&quot; password &quot;网络密码&quot; # 连接指定的无线网络</span><br></pre></td></tr></table></figure><blockquote><p>到此，基本安装完毕。</p></blockquote></main><p>Oct 2024</p></div></div></div><footer class="footer"><div class="content has-text-centered"><p><a href="/about">About Mars</a> | <a href="https://github.com/marsevilspirit" , target="_blank">Github</a> | <a href="mailto:marsevilspirit@gmail.com">Email</a></p></div></footer></body></html>